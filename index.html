<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Tay's Super Cool Flappy Game</title>
  <style>
    /* Basic reset */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      height: 100%;
      overflow: hidden; /* Prevent scrolling */
      font-family: 'Press Start 2P', cursive; /* Use the pixel-art font */
      background: #70c5ce; /* Sky blue background */
      display: flex; /* Center the canvas */
      justify-content: center;
      align-items: center;
    }
    canvas {
      display: block; /* Remove extra space below canvas */
      margin: auto; /* Center canvas horizontally */
      /* Background will be drawn by JS for parallax, this is just a fallback */
      background: #70c5ce;
      border: 5px solid #333; /* A visible border for the game area */
      box-shadow: 0 0 20px rgba(0,0,0,0.5); /* Subtle shadow for depth */
      cursor: pointer; /* Indicates it's interactive */
    }

    /* Start Screen Styling */
    #startScreen, #loadingScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8); /* Darker overlay */
      color: white;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10; /* Ensure it's on top */
      font-family: 'Press Start 2P', cursive;
      text-align: center;
    }
    #startScreen h1 {
      font-size: 3em; /* Larger title */
      margin-bottom: 20px;
      text-shadow: 4px 4px 0px black; /* Pixelated shadow */
    }
    #startScreen p {
      font-size: 1.2em;
      margin-top: 10px;
      max-width: 80%;
      text-shadow: 2px 2px 0px black;
    }
    #startBtn {
      padding: 15px 30px; /* Larger button */
      font-size: 24px;
      margin-top: 30px;
      cursor: pointer;
      border: 3px solid white; /* White border */
      background: #ff69b4; /* Pink button */
      color: white;
      border-radius: 10px;
      box-shadow: 4px 4px 0px #ab3e75; /* Darker pink shadow */
      transition: all 0.1s ease-in-out; /* Smooth transition for hover/active */
    }
    #startBtn:hover {
      background: #ff85c6; /* Lighter pink on hover */
      box-shadow: 2px 2px 0px #ab3e75; /* Smaller shadow on hover */
      transform: translate(2px, 2px); /* Slight shift on hover */
    }
    #startBtn:active {
      background: #d44d93; /* Darker pink on click */
      box-shadow: 0px 0px 0px #ab3e75;
      transform: translate(4px, 4px); /* Press down effect */
    }

    #loadingScreen p {
        font-size: 1.5em;
        text-shadow: 2px 2px 0px black;
    }

    /* Import a pixel-art font from Google Fonts */
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
  </style>
</head>
<body>
  <div id="loadingScreen" style="display: flex;">
    <p>Loading assets...</p>
  </div>

  <div id="startScreen" style="display: none;">
    <h1>Welcome to Tay's Flappy Game!</h1>
    <p>Guide Tay's bird through the pipes, collect coins, and beat your high score!</p>
    <button id="startBtn">Start Game</button>
  </div>

  <canvas id="gameCanvas" width="400" height="600"></canvas>

  <audio id="flapSound" src="https://cdn.pixabay.com/audio/2021/08/04/audio_3d16b3d5b0.mp3" preload="auto"></audio>
  <audio id="coinSound" src="https://cdn.pixabay.com/audio/2022/03/15/audio_d2ccf813a2.mp3" preload="auto"></audio>
  <audio id="hitSound" src="https://cdn.pixabay.com/audio/2022/03/15/audio_f8bc87c53e.mp3" preload="auto"></audio>
  <audio id="scoreSound" src="https://cdn.pixabay.com/audio/2021/08/04/audio_3d16b3d5b0.mp3" preload="auto"></audio> <audio id="bgMusic" src="https://cdn.pixabay.com/audio/2022/03/15/audio_2f42f6c837.mp3" loop preload="auto"></audio>


  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // Get HTML elements
    const startScreen = document.getElementById("startScreen");
    const startBtn = document.getElementById("startBtn");
    const loadingScreen = document.getElementById("loadingScreen");

    // Object to store loaded image assets
    const assets = {};
    // Paths to image sources - USING YOUR NEW GITHUB/OPEN GAME ART LINKS
    const imageSources = {
      bird: "https://raw.githubusercontent.com/samuelcust/flappy-bird-assets/master/sprites/yellowbird-midflap.png",
      pipeTop: "https://raw.githubusercontent.com/samuelcust/flappy-bird-assets/master/sprites/pipe-green-top.png",
      pipeBottom: "https://raw.githubusercontent.com/samuelcust/flappy-bird-assets/master/sprites/pipe-green-bottom.png",
      coin: "https://opengameart.org/sites/default/files/coin_24.png",
      // Using a different background, as the Pixabay one might be too large/slow for background-size: cover in JS
      // A small, repeatable pattern is better for JS-driven parallax.
      background: "https://www.transparenttextures.com/patterns/cubes.png",
    };

    let assetsLoadedCount = 0;
    const totalAssets = Object.keys(imageSources).length;

    // Function to load all necessary game assets (images)
    function loadAssets() {
      loadingScreen.style.display = 'flex'; // Show loading screen
      for (const key in imageSources) {
        const img = new Image();
        img.src = imageSources[key];
        img.onload = () => {
          assetsLoadedCount++;
          assets[key] = img; // Store loaded image in assets object
          if (assetsLoadedCount === totalAssets) {
            // All assets loaded, hide loading screen and show start screen
            loadingScreen.style.display = 'none';
            initGame(); // Call initGame after all assets are loaded
          }
        };
        img.onerror = () => {
          console.error(`Failed to load image: ${imageSources[key]}. Please check the URL and ensure it allows cross-origin access.`);
          assetsLoadedCount++; // Still increment to avoid endless waiting if an asset fails
          if (assetsLoadedCount === totalAssets) {
            loadingScreen.style.display = 'none';
            initGame();
          }
        };
      }
    }

    // References to audio elements
    const flapSound = document.getElementById("flapSound");
    const coinSound = document.getElementById("coinSound");
    const hitSound = document.getElementById("hitSound");
    const scoreSound = document.getElementById("scoreSound");
    const bgMusic = document.getElementById("bgMusic");

    // Game state variables
    let bird;
    let pipes = [];
    let coins = [];
    let score = 0;
    // Ensure high score is a number, not a string
    let highScore = Number(localStorage.getItem("highScore")) || 0;
    let frame = 0;
    let gameState = 'loading'; // New initial state: 'loading', 'ready', 'playing', 'gameOver'
    let backgroundX = 0; // For background scrolling effect

    // Game constants for easy tuning
    const PIPE_WIDTH = 52;
    const PIPE_GAP_HEIGHT = 180; // Gap size between top and bottom pipes
    const PIPE_SPEED = 2; // Speed at which pipes move
    const PIPE_SPAWN_INTERVAL = 90; // How many frames between new pipe spawns

    // --- Classes for better organization and object-oriented design ---

    class Bird {
      constructor() {
        this.x = 80;
        // Calculate initial Y based on bird image height if loaded, otherwise a default
        this.y = canvas.height / 2 - (assets.bird ? assets.bird.height / 2 : 12);
        this.width = 34; // Bird image width
        this.height = 24; // Bird image height
        this.velocity = 0;
        this.gravity = 0.4; // How fast the bird falls
        this.lift = -7; // How much the bird jumps up
      }

      draw() {
        if (!assets.bird) return; // Don't draw if image not loaded
        // Simple up-down animation for bird to make it feel alive
        const animationOffset = Math.sin(frame * 0.1) * 2; // Subtle vertical bobbing
        ctx.drawImage(assets.bird, this.x, this.y + animationOffset, this.width, this.height);
      }

      update() {
        this.velocity += this.gravity;
        this.y += this.velocity;

        // Prevent bird from going off top of screen
        if (this.y < 0) {
          this.y = 0;
          this.velocity = 0;
        }
      }

      flap() {
        this.velocity = this.lift;
        flapSound.currentTime = 0; // Reset sound to play from start even if rapidly clicked
        flapSound.play().catch(e => console.log("Flap sound failed to play:", e)); // Catch potential browser errors
      }
    }

    class Pipe {
      constructor(x) {
        this.x = x;
        this.width = PIPE_WIDTH;
        // Randomize the top pipe height, ensuring enough space for the gap and margins
        this.top = Math.random() * (canvas.height - PIPE_GAP_HEIGHT - 150) + 50; // Min 50px from top, max ensures bottom pipe fits
        this.bottom = this.top + PIPE_GAP_HEIGHT;
        this.passed = false; // To track if bird has passed it for scoring
      }

      draw() {
        if (!assets.pipeTop || !assets.pipeBottom) return; // Don't draw if images not loaded
        ctx.drawImage(assets.pipeTop, this.x, this.top - 320, this.width, 320); // Pipe images are typically tall
        ctx.drawImage(assets.pipeBottom, this.x, this.bottom, this.width, 320);
      }

      update() {
        this.x -= PIPE_SPEED;
      }
    }

    class Coin {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 25; // Coin image dimensions
        this.height = 25;
        this.collected = false;
        this.animationScale = 1; // For a simple pulse animation
      }

      draw() {
        if (!this.collected && assets.coin) {
          // Simple pulse animation for coin
          this.animationScale = 1 + Math.sin(frame * 0.1) * 0.05; // Scales from 0.95 to 1.05
          ctx.drawImage(assets.coin,
            this.x - (this.width * (this.animationScale - 1) / 2), // Adjust X to keep centered during scale
            this.y - (this.height * (this.animationScale - 1) / 2), // Adjust Y to keep centered during scale
            this.width * this.animationScale,
            this.height * this.animationScale
          );
        }
      }

      update() {
        this.x -= PIPE_SPEED;
      }
    }

    // --- Game Functions ---

    // Initializes game settings and sets up initial event listeners
    function initGame() {
      bird = new Bird(); // Create the bird instance
      startScreen.style.display = 'flex'; // Show start screen after assets load
      gameState = 'ready'; // Set initial game state to 'ready'

      // Set audio volumes
      bgMusic.volume = 0.3;
      flapSound.volume = 0.5;
      coinSound.volume = 0.6;
      hitSound.volume = 0.7;
      scoreSound.volume = 0.5;

      // Attach event listeners for input
      document.addEventListener("keydown", handleInput);
      canvas.addEventListener("click", handleInput);
      startBtn.addEventListener("click", () => {
          startScreen.style.display = 'none';
          resetGame(); // Reset game state and start playing
          bgMusic.play().catch(err => console.log("Background music failed to play:", err));
      });

      gameLoop(); // Start the main game loop (it will draw the ready screen)
    }

    // Handles all user input (keyboard and click)
    function handleInput(e) {
      // Only respond to space or arrow up keys if keydown event
      if (e.type === 'keydown' && !(e.code === "Space" || e.code === "ArrowUp")) {
        return;
      }

      if (gameState === 'ready') {
        // This state is handled by the start button now, but this provides a fallback
        // if user clicks/keys before start button is clicked
        if (startScreen.style.display !== 'none') { // Only if start screen is visible
            startScreen.style.display = 'none';
            resetGame();
            bgMusic.play().catch(err => console.log("Background music failed to play:", err));
        }
      } else if (gameState === 'playing') {
        bird.flap();
      } else if (gameState === 'gameOver') {
        resetGame(); // Restart game on interaction
        bgMusic.play().catch(err => console.log("Background music failed to play:", err));
      }
    }

    // Resets all game variables to their initial state
    function resetGame() {
      bird = new Bird(); // Re-initialize bird to its starting position
      pipes = [];
      coins = [];
      score = 0;
      frame = 0; // Reset frame count for consistent pipe spawning
      highScore = Number(localStorage.getItem("highScore")) || 0; // Refresh high score from local storage
      gameState = 'playing'; // Directly go to 'playing' state after reset
      bgMusic.pause(); // Pause music when resetting
      bgMusic.currentTime = 0; // Rewind music
    }

    // Spawns a new pipe and a coin associated with it
    function spawnPipeAndCoin() {
      const newPipe = new Pipe(canvas.width);
      pipes.push(newPipe);

      // Spawn coin centered horizontally in the pipe gap
      const coinY = newPipe.top + PIPE_GAP_HEIGHT / 2 - (new Coin(0,0).height / 2); // Center coin vertically
      coins.push(new Coin(canvas.width + PIPE_WIDTH / 2 - (new Coin(0,0).width / 2), coinY));
    }

    // Detects collisions between bird and pipes/ground/ceiling, and bird and coins
    function detectCollisions() {
      let currentGameOver = false; // Use a local variable to decide if game is over

      // Bird with ground/ceiling
      if (bird.y + bird.height > canvas.height || bird.y < 0) {
        currentGameOver = true;
      }

      // Bird with pipes (AABB collision detection)
      pipes.forEach(pipe => {
        // Collision with top pipe
        if (
          bird.x < pipe.x + pipe.width &&
          bird.x + bird.width > pipe.x &&
          bird.y < pipe.top
        ) {
          currentGameOver = true;
        }
        // Collision with bottom pipe
        if (
          bird.x < pipe.x + pipe.width &&
          bird.x + bird.width > pipe.x &&
          bird.y + bird.height > pipe.bottom
        ) {
          currentGameOver = true;
        }

        // Score for passing a pipe (only once per pipe)
        if (pipe.x + pipe.width < bird.x && !pipe.passed) {
          score += 1; // 1 point for passing a pipe
          pipe.passed = true;
          scoreSound.currentTime = 0;
          scoreSound.play().catch(e => console.log("Score sound failed to play:", e));
        }
      });

      // Bird with coins
      coins.forEach(coin => {
        if (!coin.collected &&
          bird.x < coin.x + coin.width &&
          bird.x + bird.width > coin.x &&
          bird.y < coin.y + coin.height &&
          bird.y + bird.height > coin.y
        ) {
          coin.collected = true;
          coinSound.currentTime = 0;
          coinSound.play();
          score += 5; // 5 points for collecting a coin
        }
      });

      if (currentGameOver && gameState !== 'gameOver') { // Only trigger game over once
        gameState = 'gameOver';
        hitSound.play(); // Play hit sound when game is over
      }
    }

    // Draws the scrolling background
    function drawBackground() {
      // Draw a base sky color first
      ctx.fillStyle = '#70c5ce';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (assets.background) {
        // Draw the background pattern, scrolling it
        ctx.drawImage(assets.background, backgroundX, 0, canvas.width, canvas.height);
        ctx.drawImage(assets.background, backgroundX + canvas.width, 0, canvas.width, canvas.height);
        backgroundX -= PIPE_SPEED * 0.2; // Slower than pipes for parallax effect
        // Reset background position when it scrolls off screen
        if (backgroundX <= -canvas.width) {
          backgroundX = 0;
        }
      }
    }

    // Draws the score and high score display
    function drawHUD() {
      ctx.fillStyle = "white";
      ctx.strokeStyle = "black"; // Outline for text
      ctx.lineWidth = 3; // Thickness of the outline
      ctx.font = "24px 'Press Start 2P'"; // Use the pixel font
      ctx.textAlign = "left";

      // Draw score with outline
      ctx.strokeText("Score: " + score, 10, 40);
      ctx.fillText("Score: " + score, 10, 40);

      // Draw high score with outline
      ctx.strokeText("High: " + highScore, 10, 80);
      ctx.fillText("High: " + highScore, 10, 80);
    }

    // Draws the "Game Over" screen
    function drawGameOverScreen() {
      bgMusic.pause(); // Pause background music on game over
      highScore = Math.max(score, highScore); // Update high score
      localStorage.setItem("highScore", highScore); // Save high score to local storage

      ctx.fillStyle = "rgba(0,0,0,0.7)"; // Darker overlay for game over
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "white";
      ctx.textAlign = "center";
      ctx.font = "40px 'Press Start 2P'";
      ctx.strokeText("GAME OVER!", canvas.width / 2, canvas.height / 2 - 60);
      ctx.fillText("GAME OVER!", canvas.width / 2, canvas.height / 2 - 60);

      ctx.font = "24px 'Press Start 2P'";
      ctx.strokeText("Score: " + score, canvas.width / 2, canvas.height / 2);
      ctx.fillText("Score: " + score, canvas.width / 2, canvas.height / 2);

      ctx.strokeText("High Score: " + highScore, canvas.width / 2, canvas.height / 2 + 40);
      ctx.fillText("High Score: " + highScore, canvas.width / 2, canvas.height / 2 + 40);

      ctx.font = "18px 'Press Start 2P'";
      ctx.strokeText("Click or Space to Restart", canvas.width / 2, canvas.height / 2 + 100);
      ctx.fillText("Click or Space to Restart", canvas.width / 2, canvas.height / 2 + 100);
    }

    // --- Main Game Loop ---
    function gameLoop() {
      // Always draw background first, regardless of game state
      drawBackground();

      if (gameState === 'loading') {
        // Do nothing specific here, loading screen is handled by CSS display
      } else if (gameState === 'ready') {
        // Game is ready, but waiting for user to click "Start Game" button
        // The startScreen div handles this display
      } else if (gameState === 'playing') {
        frame++; // Increment frame count

        // Spawn new pipes and coins at a regular interval
        if (frame % PIPE_SPAWN_INTERVAL === 0) {
          spawnPipeAndCoin();
        }

        // Update positions of all game elements
        bird.update();
        pipes.forEach(pipe => pipe.update());
        coins.forEach(coin => coin.update());

        // Filter out elements that have moved off-screen to keep arrays clean
        pipes = pipes.filter(pipe => pipe.x + pipe.width > 0);
        coins = coins.filter(coin => !coin.collected || coin.x + coin.width > 0); // Keep uncollected coins until off-screen

        // Draw elements in proper order (background -> pipes -> coins -> bird)
        pipes.forEach(pipe => pipe.draw());
        coins.forEach(coin => coin.draw());
        bird.draw();

        // Check for any collisions
        detectCollisions();

        // Draw the Heads-Up Display (score, high score) last
        drawHUD();

      } else if (gameState === 'gameOver') {
        drawGameOverScreen(); // Display game over screen
      }

      // Request next animation frame to continue the loop
      requestAnimationFrame(gameLoop);
    }

    // Start loading assets when the script begins execution
    loadAssets();
  </script>
</body>
</html>

